/*
   Волков Юрий Владимирович, (ИВТз-191) ИВТз19-205

   Семинар 3
   Вариант 5
      1. Найти максимальный элемент массива.
      2. Найти сумму элементов массива, расположенных до последнего положительного
         элемента.
      3. Сжать массив, удалив из него все элементы, модуль которых находится в интервале 
         [a, b]. Освободившиеся в конце массива элементы заполнить нулями.

   Использован стандарт языка С++17, если у вас не компилируется
   необходимо в "Проект -> настройки проекта -> Язык -> Стандарт языка" выбрать ISO С++17
*/
#include <iostream>   // содержит определения для стандартных потоков ввода/вывода
#include <algorithm>  // содержит алгоритмы, которые я буду использовать для решения заданий
#include <random>     // необходим для заполнения масиива случайными данными

// функция для заполнения массива случайными данными
void fiil_random(double* begin, const double* end) {
   std::default_random_engine rand_engine;            // экземпляр генератора рандомных чисел
   rand_engine.seed(std::random_device()());          // рассыпаем значения
   std::uniform_real_distribution<double> uniform;    // необходим для получения случайных вещественных значений

   while (begin != end) {
      *begin = uniform(rand_engine, decltype(uniform)::param_type(-1000.0, 1000.0)); // получаем вещественное значение в диапазоне [-1000, 1000)
      ++begin;
   }
}

// перегрузка оператора вывода в поток статического массива вещественных чисел
template<size_t size>
  std::ostream& operator<<(std::ostream& os, double (&arr)[size]) {
    for (int i = 0; i < size; ++i) {
      os << arr[i] << ", ";
    }
    return os;
  }

int main(int argc, char** argv)
{
   const size_t ARRAY_SIZE = 20;
   double _array[ARRAY_SIZE]; 

   // std::begin - получает итератор на начало массива, std::end - получает итератор на элемент за последним.
   fiil_random(std::begin(_array), std::end(_array)); // заполняем случайными значениями весь массив
   
   std::cout << _array << '\n'; // вывод массива в консоль при помощи перегруженного оператора '<<'

   // Решение: 1. Найти максимальный элемент массива.
   double max_element = *std::max_element(std::begin(_array), std::end(_array)); // находим максимальный элемент в массиве
   std::cout << "Max element: " << max_element << '\n'; // выводим найденный элемент

   // Решение: 2. Найти сумму элементов массива, расположенных до последнего положительного элемента.
   // ищем первый отрицательный элемент
   double* last_positive = std::find_if( std::begin(_array)
                                       , std::end(_array)
                                       , [](double el) { return el < 0; });

   // если итератор не в начале списка, значит нужно вернуться на последний положительный
   if (last_positive != std::begin(_array)) last_positive--;

   // находим сумму элементов до последнего положительного
   double* beg = std::begin(_array);
   double buffer = 0;
   while (beg != last_positive) {
     buffer += *beg++;
   }

   std::cout << "Summ element before last positive: " << buffer << '\n';

   // Решение: 3. Сжать массив, удалив из него все элементы, модуль которых находится в интервале 
   //             [a, b]. Освободившиеся в конце массива элементы заполнить нулями.
   // устанавливаем границы для сжатия
   double left_border = -100 
        , right_border = 500;

   beg = std::begin(_array);                              // обновляем итератор на начало
   double* end = std::end(_array);                        // получаем конец массива

   while (beg != end) {
     double abs = std::fabs(*beg);                        // получаем модуль числа
     
     if (abs >= left_border && abs <= right_border) {     // если модуль находится в диапазоне
       std::swap(*beg, *(--end));                         // переходим на последний неудаленный элемент и меняем местами с текущим
     }
     else {                                               // если значение не нужно удалять
       beg++;                                             // инкрементируем итератор
     }
   }

   std::fill(end, std::end(_array), 0.0);                 // обнуляем все элементы, которые были отфильтрованы циклом выше

   std::cout << "Compressed array: " << _array << '\n';   // выводим сжатый список в консоль

   return 0;
}

